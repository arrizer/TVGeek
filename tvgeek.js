// Generated by CoffeeScript 1.10.0
(function() {
  var App, Async, CLI, CLIColor, Config, File, FileSystem, HTTP, LibXML, Log, Path, PushoverAPI, Request, SizeFormatter, TheTVDBAPI, app, log, options, sprintf,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  FileSystem = require('fs');

  Path = require('path');

  HTTP = require('http');

  sprintf = require('sprintf').sprintf;

  LibXML = require('libxmljs');

  Async = require('async');

  CLIColor = require('cli-color');

  CLI = require('commander');

  Request = require('request');

  options = {};

  Log = (function() {
    var LEVELS;

    LEVELS = {
      debug: {
        level: 0,
        colors: ['blue'],
        textColors: ['blackBright']
      },
      info: {
        level: 1,
        colors: ['cyan'],
        textColors: []
      },
      warn: {
        level: 2,
        colors: ['black', 'bgYellow'],
        textColors: ['yellow']
      },
      error: {
        level: 3,
        colors: ['red'],
        textColors: ['red']
      },
      fatal: {
        level: 4,
        colors: ['white', 'bgRedBright'],
        textColors: ['red']
      }
    };

    Log.StdErr = function() {
      return new Log(process.stderr);
    };

    function Log(stream) {
      var fn, level;
      this.stream = stream;
      this.colored = true;
      this.timestamp = false;
      this.level = 0;
      this.buffer = '';
      this.paused = false;
      fn = (function(_this) {
        return function(level) {
          return _this[level] = function() {
            var message, parameters;
            message = arguments[0], parameters = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return _this.log.apply(_this, [level, message].concat(slice.call(parameters)));
          };
        };
      })(this);
      for (level in LEVELS) {
        fn(level);
      }
    }

    Log.prototype.colorize = function() {
      var chain, color, colors, i, len, string;
      string = arguments[0], colors = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!this.colored || (colors == null) || colors.length === 0) {
        return string;
      }
      chain = CLIColor;
      for (i = 0, len = colors.length; i < len; i++) {
        color = colors[i];
        chain = chain[color];
      }
      return chain(string);
    };

    Log.prototype.log = function() {
      var level, line, message, parameters;
      level = arguments[0], message = arguments[1], parameters = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (!(LEVELS[level].level >= this.level)) {
        return;
      }
      line = '';
      if (this.timestamp) {
        line += this.colorize('[' + new Date() + '] ', 'blackBright');
      }
      line += this.colorize.apply(this, ['[' + level.toUpperCase() + ']'].concat(slice.call(LEVELS[level].colors)));
      line += ' ' + this.colorize.apply(this, [sprintf.apply(null, [message].concat(slice.call(parameters)))].concat(slice.call(LEVELS[level].textColors)));
      return this.write(line + "\n");
    };

    Log.prototype.write = function(message) {
      if (this.paused) {
        return this.buffer += message;
      } else {
        return this.stream.write(message, 'utf8');
      }
    };

    Log.prototype.pause = function() {
      return this.paused = true;
    };

    Log.prototype.resume = function() {
      this.paused = false;
      this.write(this.buffer);
      return this.buffer = '';
    };

    return Log;

  })();

  log = Log.StdErr();

  Config = (function() {
    var DEFAULTS;

    DEFAULTS = {
      inbox: null,
      library: null,
      structure: '%show_sortable%/Season %season%/%show% S%season_00%E%episode_00% %title%',
      policy: 'replaceWhenBigger',
      considerExtensions: ["mp4", "mkv", "avi", "mov"],
      deleteExtensions: [],
      pushoverAPIToken: null,
      pushoverUserKey: null
    };

    function Config(file1) {
      this.file = file1;
    }

    Config.prototype.read = function(next) {
      return FileSystem.readFile(this.file, (function(_this) {
        return function(error, data) {
          if (error != null) {
            return next(error);
          } else {
            _this.load(JSON.parse(data.toString()));
            return next();
          }
        };
      })(this));
    };

    Config.prototype.load = function(config) {
      var key;
      this.config = DEFAULTS;
      for (key in config) {
        if (key in DEFAULTS) {
          this.config[key] = config[key];
        } else {
          log.warn('Unknown option "%s" in configuration file', key);
        }
      }
      return this.config.considerExtensions = this.config.considerExtensions.map(function(extension) {
        return '.' + extension;
      });
    };

    Config.prototype.get = function() {
      return this.config;
    };

    return Config;

  })();

  PushoverAPI = (function() {
    function PushoverAPI(appToken, userKey) {
      this.appToken = appToken;
      this.userKey = userKey;
      this.sendPushNotification = bind(this.sendPushNotification, this);
    }

    PushoverAPI.prototype.sendPushNotification = function(title, message, next) {
      var formData;
      formData = {
        token: this.appToken,
        user: this.userKey,
        title: title,
        message: message
      };
      return Request({
        method: 'POST',
        url: 'https://api.pushover.net/1/messages.json',
        formData: formData,
        form: true
      }, (function(_this) {
        return function(error, response, data) {
          console.log(data);
          return next(error);
        };
      })(this));
    };

    return PushoverAPI;

  })();

  TheTVDBAPI = (function() {
    var API_KEY, BASE;

    function TheTVDBAPI() {}

    API_KEY = '5EFCC7790F190138';

    BASE = 'http://thetvdb.com';

    TheTVDBAPI.prototype.requestXML = function(url, next) {
      return Request({
        method: "GET",
        url: url
      }, (function(_this) {
        return function(error, response, data) {
          var apiError, error1, parserError, xml;
          if (error != null) {
            return next(error);
          } else {
            try {
              xml = LibXML.parseXmlString(data);
            } catch (error1) {
              parserError = error1;
              return next(new Error("XML parser error: " + parserError + "\nXML:\n" + data));
            }
            apiError = xml.get('/Data/Error');
            if (apiError != null) {
              return next(new Error("TVDB API Error: " + apiError.toString()));
            } else {
              return next(null, xml);
            }
          }
        };
      })(this));
    };

    TheTVDBAPI.prototype.show = function(name, next) {
      return this.requestXML((BASE + "/api/GetSeries.php?seriesname=") + encodeURIComponent(name), (function(_this) {
        return function(error, xml) {
          var get, i, len, node, ref, shows;
          if (error != null) {
            return next(error);
          } else {
            shows = [];
            ref = xml.find('/Data/Series');
            for (i = 0, len = ref.length; i < len; i++) {
              node = ref[i];
              get = function(path) {
                var subnode;
                subnode = node.get(path);
                if (subnode != null) {
                  return subnode.text();
                } else {
                  return null;
                }
              };
              shows.push({
                id: get('seriesid'),
                language: get('language'),
                name: get('SeriesName'),
                since: get('FirstAired')
              });
            }
            return next(null, shows);
          }
        };
      })(this));
    };

    TheTVDBAPI.prototype.episodeByAirdate = function(showID, airdate, next) {
      airdate = sprintf('%04f-%02f-%02f', airdate.getFullYear(), airdate.getMonth() + 1, airdate.getDate());
      return this.episodeByURL(BASE + "/api/GetEpisodeByAirDate.php?apikey=" + API_KEY + "&seriesid=" + showID + "&airdate=" + airdate, next);
    };

    TheTVDBAPI.prototype.episodeBySeasonAndEpisode = function(showID, season, episode, next) {
      return this.episodeByURL(BASE + "/api/" + API_KEY + "/series/" + showID + "/default/" + season + "/" + episode + "/en.xml", next);
    };

    TheTVDBAPI.prototype.episodeByURL = function(url, next) {
      return this.requestXML(url, (function(_this) {
        return function(error, xml) {
          var episode, get;
          if (error != null) {
            return next(error);
          } else {
            get = function(key) {
              var node;
              node = xml.get('/Data/Episode/' + key);
              if (node != null) {
                return node.text();
              } else {
                return null;
              }
            };
            episode = {
              id: get('id'),
              airdate: get('FirstAired'),
              title: get('EpisodeName'),
              season: get('SeasonNumber'),
              episode: get('EpisodeNumber'),
              director: get('Director')
            };
            return next(null, episode);
          }
        };
      })(this));
    };

    return TheTVDBAPI;

  })();

  SizeFormatter = (function() {
    var UNITS;

    function SizeFormatter() {}

    UNITS = ['bytes', 'KiB', 'MiB', 'GiB', 'PiB'];

    SizeFormatter.Format = function(bytes) {
      var factor, unit;
      factor = 1;
      unit = 0;
      while ((factor * 1024) < bytes) {
        factor *= 1024;
        unit++;
      }
      return (Math.round((bytes / factor) * 100) / 100) + ' ' + UNITS[unit];
    };

    return SizeFormatter;

  })();

  File = (function() {
    var AIRDATE_RE, DELIMITERS, SEASON_EPISODE_RE, TVDB, sortable;

    SEASON_EPISODE_RE = [/^(.*) season\s*(\d+)\s*episode\s*(\d+)/gi, /^(.*) s(\d+)e(\d+)/gi, /^(.*?) (\d{1})(\d{2}) /gi, /^(.*?) (\d{1,2})x(\d{1,2})/gi];

    AIRDATE_RE = [/^(.*) (\d{4}) (\d{2}) (\d{2})/gi];

    TVDB = new TheTVDBAPI();

    DELIMITERS = /[\s,\.\-\+]+/g;

    sortable = function(string) {
      var i, len, prefix, ref, regexp;
      ref = ['The', 'Der', 'Die', 'Das', 'Le', 'Les', 'La', 'Los'];
      for (i = 0, len = ref.length; i < len; i++) {
        prefix = ref[i];
        regexp = new RegExp('^' + prefix + ' ', 'i');
        if (regexp.test(string)) {
          return string.replace(regexp, '') + ', ' + prefix;
        }
      }
      return string;
    };

    function File(directory1, filename1) {
      this.directory = directory1;
      this.filename = filename1;
      this.extension = Path.extname(this.filename);
      this.name = Path.basename(this.filename, this.extension);
      this.filepath = Path.join(this.directory, this.filename);
      this.info = {};
    }

    File.prototype.match = function(next) {
      log.info('Matching "%s"', this.filename);
      this.nameNormalized = this.name.replace(DELIMITERS, ' ');
      return Async.series([this.extract.bind(this), this.fetchShow.bind(this), this.fetchEpisode.bind(this)], (function(_this) {
        return function(error) {
          if (error != null) {
            log.error("%s: %s", _this.filename, error);
          }
          return next(error);
        };
      })(this));
    };

    File.prototype.extract = function(next) {
      var i, len, method, ref;
      ref = ['extractSeasonAndEpisode', 'extractAirdate'];
      for (i = 0, len = ref.length; i < len; i++) {
        method = ref[i];
        if (this[method]()) {
          return next();
        }
      }
      return next(new Error("Could not extract season/episode or airdate from '" + this.nameNormalized + "'"));
    };

    File.prototype.extractSeasonAndEpisode = function() {
      var i, len, match, regexp;
      log.debug('Extracting season/episode from "%s"', this.nameNormalized);
      for (i = 0, len = SEASON_EPISODE_RE.length; i < len; i++) {
        regexp = SEASON_EPISODE_RE[i];
        match = regexp.exec(this.nameNormalized);
        if (match != null) {
          this.extracted = {
            fetch: 'fetchEpisodeBySeasonAndEpisode',
            show: match[1],
            season: parseInt(match[2]),
            episode: parseInt(match[3])
          };
          log.debug('Extracted -> "%s" S%02fE%02f', this.extracted.show, this.extracted.season, this.extracted.episode);
          regexp.lastIndex = 0;
          return true;
        }
      }
      return false;
    };

    File.prototype.extractAirdate = function(next) {
      var i, len, match, regexp;
      log.debug('Extracting airdate from "%s"', this.nameNormalized);
      for (i = 0, len = AIRDATE_RE.length; i < len; i++) {
        regexp = AIRDATE_RE[i];
        match = regexp.exec(this.nameNormalized);
        if (match != null) {
          this.extracted = {
            fetch: 'fetchEpisodeByAirdate',
            show: match[1],
            airdate: new Date(match[2], parseInt(match[3]) - 1, match[4])
          };
          log.debug('Extracted -> "%s" airdate %s', this.extracted.show, this.extracted.airdate);
          regexp.lastIndex = 0;
          return true;
        }
      }
      return false;
    };

    File.prototype.fetchShow = function(next) {
      return TVDB.show(this.extracted.show, (function(_this) {
        return function(error, shows) {
          if (error != null) {
            return next(new Error("Failed to get show information: " + error));
          } else {
            if (shows.length === 1) {
              return next(null, _this.show = shows[0]);
            } else if (shows.length === 0) {
              return next(new Error("Show named '" + _this.extracted.show + "' not found"));
            } else {
              return next(null, _this.show = shows[0]);
            }
          }
        };
      })(this));
    };

    File.prototype.fetchEpisode = function(next) {
      return this[this.extracted.fetch]((function(_this) {
        return function(error, episode) {
          if (error != null) {
            return next(new Error("Failed to get episode information: " + error));
          } else {
            return next(null, _this.episode = episode);
          }
        };
      })(this));
    };

    File.prototype.fetchEpisodeBySeasonAndEpisode = function(next) {
      return TVDB.episodeBySeasonAndEpisode(this.show.id, this.extracted.season, this.extracted.episode, next);
    };

    File.prototype.fetchEpisodeByAirdate = function(next) {
      return TVDB.episodeByAirdate(this.show.id, this.extracted.airdate, next);
    };

    File.prototype.libraryPath = function(pattern) {
      var escapeRegExp, key, path, placeholders, value;
      path = pattern;
      placeholders = {
        show: this.show.name,
        season: this.episode.season,
        episode: this.episode.episode,
        title: this.episode.title
      };
      for (key in placeholders) {
        value = placeholders[key];
        if (value == null) {
          value = '';
        }
        value = value.toString().replace(/(\/|\\|:|;)/g, '');
        placeholders[key] = value;
        placeholders[key + '_sortable'] = sortable(value);
        if (/^\d+$/.test(value)) {
          placeholders[key + '_00'] = sprintf('%02f', parseInt(value));
        }
      }
      escapeRegExp = function(string) {
        return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
      };
      for (key in placeholders) {
        value = placeholders[key];
        path = path.replace(new RegExp(escapeRegExp('%' + key + '%'), 'g'), value);
      }
      return path;
    };

    File.prototype.move = function(libraryDir, pattern, overwritePolicy, next) {
      var basename, libraryDirectory, path;
      path = this.libraryPath(pattern);
      basename = Path.basename(path);
      libraryDirectory = Path.join(libraryDir, Path.dirname(path));
      return this.makeLibraryPath(libraryDir, Path.dirname(path), (function(_this) {
        return function(error, existed) {
          if (error != null) {
            return next(error);
          } else {
            return _this.overwrite(libraryDirectory, basename, overwritePolicy, function(fileExisted, move) {
              if (move) {
                return _this.moveTo(libraryDir, path, next);
              } else {
                return FileSystem.unlink(Path.join(_this.directory, _this.filename), function(error) {
                  return next(error, true);
                });
              }
            });
          }
        };
      })(this));
    };

    File.prototype.overwrite = function(libraryDirectory, basename, overwritePolicy, next) {
      return FileSystem.stat(this.filepath, (function(_this) {
        return function(error, info) {
          _this.info = info;
          return FileSystem.readdir(libraryDirectory, function(error, files) {
            return Async.eachSeries(files, function(file, done) {
              var filename;
              if (Path.basename(file, Path.extname(file)) === basename) {
                filename = Path.join(libraryDirectory, file);
                return FileSystem.stat(filename, function(error, stat) {
                  var overwrite;
                  if (error != null) {
                    error = new Error("Could not get size of file " + filename + " in library: " + error);
                    return done(error);
                  }
                  overwrite = false;
                  if (overwritePolicy === 'replaceWhenBigger') {
                    if (stat.size < _this.info.size) {
                      log.warn("Smaller file '%s' in library will be replaced", file);
                      overwrite = true;
                    } else if (stat.size > _this.info.size) {
                      log.warn("Bigger file '%s' (%s > %s) already in library", file, SizeFormatter.Format(stat.size), SizeFormatter.Format(_this.info.size));
                    } else {
                      log.warn("File '%s' already in library", file);
                    }
                  } else if (overwritePolicy === 'always') {
                    log.warn("File '%s' in library will be replaced", file);
                    overwrite = true;
                  }
                  if (overwrite) {
                    return FileSystem.unlink(filename, function(error) {
                      if (error != null) {
                        log.error("Failed to remove existing file '%s' in library: %s", filename, error);
                      }
                      done(1);
                      return next(true, error == null);
                    });
                  } else {
                    done(1);
                    return next(true, false);
                  }
                });
              } else {
                return done();
              }
            }, function(error) {
              if (error == null) {
                return next(false, true);
              }
            });
          });
        };
      })(this));
    };

    File.prototype.moveTo = function(library, path, next) {
      var destination, origin;
      origin = Path.join(this.directory, this.filename);
      destination = Path.join(library, path + this.extension);
      return next();
    };

    File.prototype.makeLibraryPath = function(library, directory, next) {
      return this.makeLibraryPathRecursive(library, '', directory.split(Path.sep), next);
    };

    File.prototype.makeLibraryPathRecursive = function(library, path, remaining, next) {
      var directory, recurse;
      directory = Path.join(library, path);
      recurse = (function(_this) {
        return function() {
          if (remaining.length > 0) {
            return _this.makeLibraryPathRecursive(library, Path.join(path, remaining.shift()), remaining, next);
          } else {
            return next();
          }
        };
      })(this);
      return FileSystem.exists(directory, (function(_this) {
        return function(exists) {
          if (!exists) {
            log.debug('Creating directory "%s"', directory);
            return FileSystem.mkdir(directory, function(error) {
              if (error) {
                return next(error);
              } else {
                return recurse();
              }
            });
          } else {
            return recurse();
          }
        };
      })(this));
    };

    File.prototype.toString = function() {
      return sprintf('%s S%02fE%02f "%s" (%s)', this.show.name, parseInt(this.episode.season), parseInt(this.episode.episode), this.episode.title, SizeFormatter.Format(this.info.size));
    };

    return File;

  })();

  App = (function() {
    function App() {}

    App.prototype.main = function() {
      this.parseArguments();
      if (!CLI.verbose) {
        log.level = 1;
      }
      this.config = new Config(__dirname + '/config.json');
      return this.config.read((function(_this) {
        return function() {
          _this.config = _this.config.get();
          if ((_this.config.pushoverAPIToken != null) && (_this.config.pushoverUserKey != null)) {
            _this.pushoverAPI = new PushoverAPI(_this.config.pushoverAPIToken, _this.config.pushoverUserKey);
          }
          return _this.processFiles(_this.config.inbox);
        };
      })(this));
    };

    App.prototype.parseArguments = function() {
      return CLI.version('0.1').option('-n, --noninteractive', 'Don\'t ask anything').option('-v, --verbose', 'Log debug messages').parse(process.argv);
    };

    App.prototype.printHelp = function() {
      return console.log(this.cli.toString());
    };

    App.prototype.processFiles = function(inbox) {
      return FileSystem.readdir(inbox, (function(_this) {
        return function(error, files) {
          var extension, file, i, len, results;
          if (error != null) {
            return log.error('Failed to enumerate files in inbox "%s": %s', inbox, error);
          } else {
            results = [];
            for (i = 0, len = files.length; i < len; i++) {
              file = files[i];
              if (_this.config.considerExtensions.indexOf(Path.extname(file)) >= 0) {
                results.push(_this.processFile(inbox, file));
              } else {
                results.push((function() {
                  var j, len1, ref, results1;
                  ref = this.config.deleteExtensions;
                  results1 = [];
                  for (j = 0, len1 = ref.length; j < len1; j++) {
                    extension = ref[j];
                    if (Path.extname(file) === '.' + extension) {
                      log.info("Deleting file '%s' from inbox", file);
                      results1.push(FileSystem.unlink(Path.join(inbox, file)));
                    } else {
                      results1.push(void 0);
                    }
                  }
                  return results1;
                }).call(_this));
              }
            }
            return results;
          }
        };
      })(this));
    };

    App.prototype.processFile = function(inbox, file) {
      var item;
      item = new File(inbox, file);
      return item.match((function(_this) {
        return function(error) {
          if (error == null) {
            return item.move(_this.config.library, _this.config.structure, _this.config.policy, function(error) {
              if (error != null) {
                log.error("Failed to move '%s' to library: %s", item.filename, error);
                return;
              }
              log.info('-> %s', item.toString());
              return _this.pushoverAPI.sendPushNotification("TVGeek file added", item.toString(), function(error) {
                if (error != null) {
                  return log.error("Failed to send pushover notification for '%s': %s", item.filename, error);
                }
              });
            });
          }
        };
      })(this));
    };

    return App;

  })();

  app = new App();

  app.main();

}).call(this);
